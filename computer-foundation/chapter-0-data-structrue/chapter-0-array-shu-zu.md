# Chapter 0 思路指南

## 一、数据结构的存储方式

首先数组是一种**线性存储**的数据结构，链表是链式**存储结构**，面试时重点区分一下优缺点：

### 数组:

* 由于是紧凑的、连续的存储，通过索引进行对应位置元素的随机访问，相对来说是节约存储空间的
* 由于是连续存储，所以必须要一次性分配够内存，所以说数组在扩容的时候，需要重新分配一块更大的内存，然后再把原来的数据复制过去，时间复杂度为O\(N\).
* 在数组中进行插入或者删除操作的时候，每次必须移动目标元素后的所有数据以保持这种来连续性，时间复杂度为O\(N\)

### 链表:

* 由于元素是不连续的，是依靠指针来指向下一个元素的位置，所以不存在数组的扩容时的问题
* 如果知道一个元素的前驱和后继，操作指针就可以删除该元素或者插入新元素，时间复杂度为O\(1\)
* 正是这种内存空间不连续的特点，无法根据一个索引来计算除对应元素的地址，所以不能够随机访问
* 同时，由于每个元素必须存储指向前后元素的指针，会消耗更多的存储空间

## 数组和链表才是数据结构的基础，其他的数据结构，其源头都可以看作是在数组和链表上的特殊操作

## 二、数据结构的基本操作

### 对于任意的数据结构，基本操作包括：遍历 + 访问，即：增、删、改、查 四大操作！其意义在于：针对不同的应用场景下，尽可能高效的进行 增、删、改、查

### 遍历 + 访问的方式：线性      &       非线性

###         线性：一般指使用 for / while 迭代

###         非线性：一般指使用 递归 迭代

###         \(1\) 典型的  线性迭代结构:

```text
void traverse(int[] arr) {
    for (int i = 0; i < arr.length; i++) {
        // 迭代访问 arr[i]
    }
}
```

###          \(2\) 典型的  线性迭代 + 递归迭代 结构:

```text
/* 基本的单链表节点 */
class ListNode {
    int val;
    ListNode next;
}

void traverse(ListNode head) {
    for (ListNode p = head; p != null; p = p.next) {
        // 访问 p.val
    }
}

void traverse(ListNode head) {
    //递归访问 head.val
    traverse(head.next)
}
```

###            \(3\) 典型的  非线性迭代 结构:

```text
/* 基本的二叉树节点 */
class TreeNode {
    int val;
    TreeNode left, right;
}

void traverse(TreeNode root) {
    traverse(root.left)
    traverse(root.right)
}
```





